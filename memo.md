# minitalk との記録。

まずは、subject を読んでみる。

# minitalk

なんか、2 つ実行ファイル作成する必要があるっぽい。
client と server。
お〜ん。イマイチわからんなぁ。
どうしたらいいんやろ。

とりあえず、色々関数は使えそう。
シグナル使うのか？
あー、シグナル使うんやな。
server を先に起動する。
client を起動して、server にメッセージを送る。
文字列を送信して、それを受け取らなあかんのか。
PID は確かプロセス ID のこと。
getpid()で取得できるはず。→ 使用許可関数に含まれてるからそれで渡すのかなー。

え、これめっちゃ簡単ちゃう？文字送るだけやろ。
めっちゃ簡単そうやん。

あ、同時に複数のクライアントが接続してきたら全部並列処理しなアカンのか？

2 つのシグナルしか使用しちゃダメそう。
えー。めっちゃ簡単そうやけどな。難しいポイントどこなんやろ。
あーこれ、0, 1しか送れへんのか。
まあ、それが出来たら1bitずつ送信して終わりやな。

8bit受信して、文字化して、ってのを繰り返せば終わりそう。

signalのman, wiki, Qiitaを読んだ。
え、やっぱめっちゃ簡単そうやん。

# 使用許可関数

◦write
◦ft_printf or any equivalent YOU coded
◦signal
◦sigemptyset
◦sigaddset
◦sigaction
◦kill
◦getpid
◦malloc
◦free
◦pause
◦sleep
◦usleep
◦exit

とりあえず、これらの関数の理解度を上げる必要ある。

write, ft_printf, free, malloc はわかる。

ほかを結構詳しく調べてみる。

### signal

シグナルを処理するための関数。
あーー、なるほど。これでシグナルが送信されたときに、現在の処理を一時中断して、
異なる処理に分岐できるんや。
え、けどそれは新しいプロセスになってるってことなんか？
それとも、同じプロセスの中で処理を切り替えるってことなんかな。
うーん。送信できるなら受信もしたいよなー。
んじゃ、どうやったら違うプロセスにシグナルを送信できるんやろ。

とりあえず他の関数見るか。

### sigemptyset


### やること。
- [ ] server の実装
- [ ] client の実装
- [ ] シグナルの送受信の実装
- [ ] 文字列の送受信の実装
- [ ] 文字列の受信の実装
- [ ] 文字列の送信の実装
- [ ] 文字列の受信のテスト
- [ ] 文字列の送信のテスト
- [ ] 同時接続のテスト
- [ ] 文字列の受信のバグ修正
- [ ] 文字列の送信のバグ修正
- [ ] 同時接続のバグ修正
- [ ] ドキュメントの作成
- [ ] コードのリファクタリング
- [ ] コードの最適化
- [ ] コードのコメント追加
- [ ] コードのドキュメント化
- [ ] コードのテスト
- [ ] コードのデバッグ
- [ ] コードのレビュー
- [ ] コードのマージ
- [ ] コードのデプロイ
- [ ] コードのリリース
- [ ] コードのメンテナンス
- [ ] コードのアップデート
- [ ] コードのバグ修正
- [ ] コードのセキュリティ対策
- [ ] コードのパフォーマンス改善
- [ ] コードの可読性改善
- [ ] コードの保守性改善
- [ ] コードの拡張性改善
- [ ] コードの再利用性改善
- [ ] コードのテストカバレッジ改善
- [ ] コードのコードスタイル改善


送信。
８bit 受信して、文字化して、ってのを繰り返せば終わりそう。
